<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo: Live LLM Attention & Token Analysis</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a5f2a 0%, #2d8a4a 100%);
            color: white;
            min-height: 100vh;
        }

        .slide {
            display: none;
            min-height: 100vh;
            padding: 30px 50px;
            flex-direction: column;
        }

        .slide.active {
            display: flex;
        }

        .slide-content {
            flex: 1;
            overflow-y: auto;
        }

        h1 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 2.4em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            border-bottom: 3px solid rgba(255,255,255,0.5);
            padding-bottom: 10px;
        }

        h2 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #90EE90;
        }

        h3 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.4em;
            margin: 15px 0 10px 0;
            color: #98FB98;
        }

        p {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.1em;
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .demo-container {
            background-color: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 25px;
            margin: 15px 0;
        }

        .chart-container {
            background-color: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            max-width: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group.wide {
            flex: 1;
            min-width: 250px;
        }

        label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.95em;
            color: #90EE90;
        }

        select, input, textarea {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            font-size: 1em;
            background-color: rgba(255,255,255,0.9);
            color: #1a5f2a;
        }

        input[type="password"] {
            font-family: 'Courier New', Courier, monospace;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #90EE90;
            color: #1a5f2a;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .btn:hover:not(:disabled) {
            background-color: white;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
        }

        .api-key-section {
            background-color: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-left: 15px;
        }

        .api-status.connected {
            background-color: rgba(144, 238, 144, 0.3);
            color: #90EE90;
        }

        .api-status.disconnected {
            background-color: rgba(255, 99, 132, 0.3);
            color: #ff6b6b;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .connected .status-dot {
            background-color: #90EE90;
        }

        .disconnected .status-dot {
            background-color: #ff6b6b;
        }

        .response-box {
            background-color: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            min-height: 100px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .response-box.loading {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #90EE90;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .token-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 15px 0;
        }

        .token {
            font-family: 'Courier New', Courier, monospace;
            background-color: rgba(144, 238, 144, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            border: 1px solid rgba(144, 238, 144, 0.5);
        }

        .token.highlight {
            background-color: rgba(144, 238, 144, 0.6);
            border-color: #90EE90;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        .highlight-box {
            background-color: rgba(255,255,255,0.15);
            border-left: 4px solid #90EE90;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        .code-table {
            width: 100%;
            max-width: 100%;
            margin: 15px 0;
            border-collapse: collapse;
            background-color: #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
        }

        .code-table td {
            padding: 15px;
        }

        .code-table code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            color: #00ff00;
            white-space: pre;
            display: block;
            line-height: 1.4;
        }

        .code-label {
            background-color: #2d2d44;
            color: #90EE90;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.85em;
            padding: 8px 15px !important;
            border-bottom: 1px solid #444;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-top: auto;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .nav-btn {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 10px 25px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background-color: white;
            color: #1a5f2a;
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slide-counter {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em;
            opacity: 0.8;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 15px 0;
        }

        .stat-card {
            background-color: rgba(255,255,255,0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.8em;
            font-weight: bold;
            color: #90EE90;
        }

        .stat-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.85em;
            opacity: 0.8;
        }

        .error-message {
            background-color: rgba(255, 99, 132, 0.2);
            border: 1px solid rgba(255, 99, 132, 0.5);
            color: #ff6b6b;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .model-select {
            min-width: 200px;
        }

        ul {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin-left: 25px;
            line-height: 1.8;
        }

        @media (max-width: 900px) {
            .two-column {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, createContext, useContext } = React;

        // API Context for sharing key across slides
        const ApiContext = createContext();

        // Slide 1: Title & API Setup
        function TitleSlide({ apiKey, setApiKey, isConnected, setIsConnected }) {
            const [testingConnection, setTestingConnection] = useState(false);
            const [error, setError] = useState('');

            const testConnection = async () => {
                if (!apiKey.trim()) {
                    setError('Please enter an API key');
                    return;
                }

                setTestingConnection(true);
                setError('');

                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });

                    if (response.ok) {
                        setIsConnected(true);
                        setError('');
                    } else {
                        const data = await response.json();
                        setError(data.error?.message || 'Invalid API key');
                        setIsConnected(false);
                    }
                } catch (err) {
                    setError('Connection failed. Check your network.');
                    setIsConnected(false);
                }

                setTestingConnection(false);
            };

            return (
                <div className="slide-content">
                    <div style={{textAlign: 'center', marginBottom: '30px'}}>
                        <h2 style={{marginBottom: '10px'}}>Interactive Demo</h2>
                        <h1 style={{fontSize: '2.8em', borderBottom: 'none'}}>Live LLM Token Analysis</h1>
                        <p style={{fontSize: '1.2em', opacity: 0.9}}>Understanding Tokenization & Model Responses</p>
                    </div>

                    <div className="api-key-section">
                        <h3>
                            OpenAI API Connection
                            <span className={`api-status ${isConnected ? 'connected' : 'disconnected'}`}>
                                <span className="status-dot"></span>
                                {isConnected ? 'Connected' : 'Not Connected'}
                            </span>
                        </h3>
                        <p style={{opacity: 0.8, marginBottom: '15px'}}>
                            Enter your OpenAI API key to enable live demonstrations. Your key is stored only in browser memory and never sent to any server except OpenAI.
                        </p>
                        <div className="controls">
                            <div className="control-group wide">
                                <label>API Key:</label>
                                <input
                                    type="password"
                                    value={apiKey}
                                    onChange={(e) => setApiKey(e.target.value)}
                                    placeholder="sk-..."
                                    style={{width: '100%'}}
                                />
                            </div>
                            <div className="control-group">
                                <label>&nbsp;</label>
                                <button
                                    className="btn"
                                    onClick={testConnection}
                                    disabled={testingConnection}
                                >
                                    {testingConnection ? 'Testing...' : 'Test Connection'}
                                </button>
                            </div>
                        </div>
                        {error && <div className="error-message">{error}</div>}
                    </div>

                    <div className="highlight-box">
                        <h3>What This Demo Covers</h3>
                        <ul>
                            <li>Live tokenization of text input</li>
                            <li>Token count and cost estimation</li>
                            <li>Real-time LLM completions with streaming</li>
                            <li>Response time and performance metrics</li>
                            <li>Temperature and parameter effects</li>
                        </ul>
                    </div>
                </div>
            );
        }

        // Slide 2: Live Tokenization
        function TokenizationSlide({ apiKey, isConnected }) {
            const [inputText, setInputText] = useState('The quick brown fox jumps over the lazy dog.');
            const [tokens, setTokens] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [tokenStats, setTokenStats] = useState({ count: 0, chars: 0, ratio: 0 });

            // Simple tokenization approximation (GPT-style)
            const approximateTokenize = (text) => {
                // This approximates GPT tokenization patterns
                const patterns = [
                    /\s+/g,  // whitespace
                    /[.,!?;:'"()\[\]{}]/g,  // punctuation
                ];

                let tokens = [];
                let remaining = text;

                // Split by spaces first, keeping track of spaces
                const parts = text.split(/(\s+)/);

                parts.forEach(part => {
                    if (part.match(/^\s+$/)) {
                        // It's whitespace - often merged with next token
                        if (tokens.length > 0) {
                            tokens[tokens.length - 1] = tokens[tokens.length - 1];
                        }
                    } else if (part.length > 0) {
                        // Split long words into subwords (approximate BPE)
                        if (part.length > 6) {
                            // Rough approximation of subword tokenization
                            const subwords = [];
                            let i = 0;
                            while (i < part.length) {
                                const len = Math.min(4 + Math.floor(Math.random() * 3), part.length - i);
                                subwords.push((i === 0 ? '' : '##') + part.slice(i, i + len));
                                i += len;
                            }
                            tokens.push(...subwords);
                        } else {
                            tokens.push(part);
                        }
                    }
                });

                return tokens;
            };

            const tokenize = async () => {
                if (!inputText.trim()) return;

                setLoading(true);
                setError('');

                // Use approximation for display
                const approxTokens = approximateTokenize(inputText);
                setTokens(approxTokens);

                // Calculate stats
                const count = approxTokens.length;
                const chars = inputText.length;
                setTokenStats({
                    count,
                    chars,
                    ratio: (chars / count).toFixed(2)
                });

                // If connected, get actual token count from API
                if (isConnected && apiKey) {
                    try {
                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: 'gpt-3.5-turbo',
                                messages: [{ role: 'user', content: inputText }],
                                max_tokens: 1
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            const actualCount = data.usage?.prompt_tokens || count;
                            setTokenStats(prev => ({
                                ...prev,
                                count: actualCount,
                                ratio: (chars / actualCount).toFixed(2),
                                actual: true
                            }));
                        }
                    } catch (err) {
                        // Silently fall back to approximation
                    }
                }

                setLoading(false);
            };

            useEffect(() => {
                tokenize();
            }, []);

            return (
                <div className="slide-content">
                    <h1>Live Tokenization Analysis</h1>
                    <p>See how text is broken into tokens before being processed by the LLM.</p>

                    <div className="demo-container">
                        <div className="controls">
                            <div className="control-group wide">
                                <label>Input Text:</label>
                                <textarea
                                    value={inputText}
                                    onChange={(e) => setInputText(e.target.value)}
                                    placeholder="Enter text to tokenize..."
                                    style={{width: '100%'}}
                                />
                            </div>
                            <div className="control-group">
                                <label>&nbsp;</label>
                                <button className="btn" onClick={tokenize} disabled={loading}>
                                    {loading ? 'Tokenizing...' : 'Tokenize'}
                                </button>
                            </div>
                        </div>

                        <div className="stats-grid">
                            <div className="stat-card">
                                <div className="stat-value">{tokenStats.count}</div>
                                <div className="stat-label">Tokens {tokenStats.actual ? '(actual)' : '(approx)'}</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-value">{tokenStats.chars}</div>
                                <div className="stat-label">Characters</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-value">{tokenStats.ratio}</div>
                                <div className="stat-label">Chars/Token</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-value">${(tokenStats.count * 0.000002).toFixed(6)}</div>
                                <div className="stat-label">Est. Cost (GPT-4)</div>
                            </div>
                        </div>

                        <h3>Token Breakdown:</h3>
                        <div className="token-display">
                            {tokens.map((token, i) => (
                                <span key={i} className="token">{token}</span>
                            ))}
                        </div>

                        {error && <div className="error-message">{error}</div>}
                    </div>

                    <div className="highlight-box">
                        <p><strong>Key Insight:</strong> English text averages ~4 characters per token. Code and special characters often use more tokens per character.</p>
                    </div>
                </div>
            );
        }

        // Slide 3: Live Completion with Streaming
        function LiveCompletionSlide({ apiKey, isConnected }) {
            const [prompt, setPrompt] = useState('Explain how attention mechanisms work in transformers in 2-3 sentences.');
            const [response, setResponse] = useState('');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [model, setModel] = useState('gpt-3.5-turbo');
            const [temperature, setTemperature] = useState(0.7);
            const [metrics, setMetrics] = useState({ startTime: 0, firstToken: 0, totalTime: 0, tokens: 0 });

            const runCompletion = async () => {
                if (!isConnected || !apiKey) {
                    setError('Please connect your API key on the first slide.');
                    return;
                }

                setLoading(true);
                setResponse('');
                setError('');

                const startTime = performance.now();
                let firstTokenTime = 0;
                let tokenCount = 0;

                try {
                    const res = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [{ role: 'user', content: prompt }],
                            temperature: parseFloat(temperature),
                            stream: true
                        })
                    });

                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.error?.message || 'API request failed');
                    }

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let fullResponse = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') continue;

                                try {
                                    const parsed = JSON.parse(data);
                                    const content = parsed.choices?.[0]?.delta?.content;
                                    if (content) {
                                        if (firstTokenTime === 0) {
                                            firstTokenTime = performance.now() - startTime;
                                        }
                                        tokenCount++;
                                        fullResponse += content;
                                        setResponse(fullResponse);
                                    }
                                } catch (e) {
                                    // Skip malformed JSON
                                }
                            }
                        }
                    }

                    const totalTime = performance.now() - startTime;
                    setMetrics({
                        startTime,
                        firstToken: Math.round(firstTokenTime),
                        totalTime: Math.round(totalTime),
                        tokens: tokenCount,
                        tokensPerSec: (tokenCount / (totalTime / 1000)).toFixed(1)
                    });

                } catch (err) {
                    setError(err.message);
                }

                setLoading(false);
            };

            return (
                <div className="slide-content">
                    <h1>Live LLM Completion with Streaming</h1>
                    <p>Watch the model generate responses in real-time and measure performance.</p>

                    <div className="demo-container">
                        <div className="controls">
                            <div className="control-group">
                                <label>Model:</label>
                                <select
                                    className="model-select"
                                    value={model}
                                    onChange={(e) => setModel(e.target.value)}
                                >
                                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                    <option value="gpt-4">GPT-4</option>
                                    <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                                </select>
                            </div>
                            <div className="control-group">
                                <label>Temperature: {temperature}</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="2"
                                    step="0.1"
                                    value={temperature}
                                    onChange={(e) => setTemperature(e.target.value)}
                                    style={{width: '150px'}}
                                />
                            </div>
                            <div className="control-group">
                                <label>&nbsp;</label>
                                <button
                                    className="btn"
                                    onClick={runCompletion}
                                    disabled={loading || !isConnected}
                                >
                                    {loading ? 'Generating...' : 'Run Completion'}
                                </button>
                            </div>
                        </div>

                        <div className="control-group" style={{marginBottom: '15px'}}>
                            <label>Prompt:</label>
                            <textarea
                                value={prompt}
                                onChange={(e) => setPrompt(e.target.value)}
                                style={{width: '100%'}}
                            />
                        </div>

                        {metrics.totalTime > 0 && (
                            <div className="stats-grid">
                                <div className="stat-card">
                                    <div className="stat-value">{metrics.firstToken}ms</div>
                                    <div className="stat-label">Time to First Token</div>
                                </div>
                                <div className="stat-card">
                                    <div className="stat-value">{metrics.totalTime}ms</div>
                                    <div className="stat-label">Total Time</div>
                                </div>
                                <div className="stat-card">
                                    <div className="stat-value">{metrics.tokens}</div>
                                    <div className="stat-label">Output Tokens</div>
                                </div>
                                <div className="stat-card">
                                    <div className="stat-value">{metrics.tokensPerSec}</div>
                                    <div className="stat-label">Tokens/Second</div>
                                </div>
                            </div>
                        )}

                        <h3>Response:</h3>
                        <div className={`response-box ${loading && !response ? 'loading' : ''}`}>
                            {loading && !response ? (
                                <div className="spinner"></div>
                            ) : (
                                response || <span style={{opacity: 0.5}}>Response will appear here...</span>
                            )}
                        </div>

                        {error && <div className="error-message">{error}</div>}

                        {!isConnected && (
                            <div className="error-message">
                                API not connected. Please enter your API key on the first slide.
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Slide 4: Temperature Comparison
        function TemperatureComparisonSlide({ apiKey, isConnected }) {
            const [prompt, setPrompt] = useState('Complete this sentence creatively: The robot walked into the coffee shop and');
            const [responses, setResponses] = useState({ t0: '', t07: '', t15: '' });
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            const runComparison = async () => {
                if (!isConnected || !apiKey) {
                    setError('Please connect your API key on the first slide.');
                    return;
                }

                setLoading(true);
                setError('');
                setResponses({ t0: '', t07: '', t15: '' });

                const temperatures = [0, 0.7, 1.5];
                const keys = ['t0', 't07', 't15'];

                try {
                    const results = await Promise.all(
                        temperatures.map(async (temp) => {
                            const res = await fetch('https://api.openai.com/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    model: 'gpt-3.5-turbo',
                                    messages: [{ role: 'user', content: prompt }],
                                    temperature: temp,
                                    max_tokens: 100
                                })
                            });

                            if (!res.ok) {
                                throw new Error('API request failed');
                            }

                            const data = await res.json();
                            return data.choices[0].message.content;
                        })
                    );

                    setResponses({
                        t0: results[0],
                        t07: results[1],
                        t15: results[2]
                    });

                    // Update chart
                    updateChart(results);

                } catch (err) {
                    setError(err.message);
                }

                setLoading(false);
            };

            const updateChart = (results) => {
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                if (!chartRef.current) return;

                const ctx = chartRef.current.getContext('2d');

                // Calculate word diversity (unique words / total words)
                const diversity = results.map(text => {
                    const words = text.toLowerCase().split(/\s+/);
                    const unique = new Set(words);
                    return ((unique.size / words.length) * 100).toFixed(1);
                });

                const wordCount = results.map(text => text.split(/\s+/).length);

                chartInstance.current = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Temp 0.0', 'Temp 0.7', 'Temp 1.5'],
                        datasets: [
                            {
                                label: 'Word Diversity %',
                                data: diversity,
                                backgroundColor: 'rgba(144, 238, 144, 0.8)',
                                borderColor: 'rgba(26, 95, 42, 1)',
                                borderWidth: 2
                            },
                            {
                                label: 'Word Count',
                                data: wordCount,
                                backgroundColor: 'rgba(54, 162, 235, 0.8)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }
                };
            }, []);

            return (
                <div className="slide-content">
                    <h1>Temperature Effect Comparison</h1>
                    <p>See how temperature affects response creativity and variability.</p>

                    <div className="demo-container">
                        <div className="controls">
                            <div className="control-group wide">
                                <label>Prompt:</label>
                                <textarea
                                    value={prompt}
                                    onChange={(e) => setPrompt(e.target.value)}
                                    style={{width: '100%'}}
                                />
                            </div>
                            <div className="control-group">
                                <label>&nbsp;</label>
                                <button
                                    className="btn"
                                    onClick={runComparison}
                                    disabled={loading || !isConnected}
                                >
                                    {loading ? 'Running...' : 'Compare All'}
                                </button>
                            </div>
                        </div>

                        <div className="two-column">
                            <div>
                                <h3 style={{color: '#90EE90'}}>Temperature 0.0 (Deterministic)</h3>
                                <div className="response-box" style={{minHeight: '80px'}}>
                                    {responses.t0 || <span style={{opacity: 0.5}}>...</span>}
                                </div>

                                <h3 style={{color: '#FFCE56'}}>Temperature 0.7 (Balanced)</h3>
                                <div className="response-box" style={{minHeight: '80px'}}>
                                    {responses.t07 || <span style={{opacity: 0.5}}>...</span>}
                                </div>

                                <h3 style={{color: '#FF6384'}}>Temperature 1.5 (Creative)</h3>
                                <div className="response-box" style={{minHeight: '80px'}}>
                                    {responses.t15 || <span style={{opacity: 0.5}}>...</span>}
                                </div>
                            </div>

                            <div className="chart-container" style={{height: '350px'}}>
                                <canvas ref={chartRef}></canvas>
                            </div>
                        </div>

                        {error && <div className="error-message">{error}</div>}
                    </div>
                </div>
            );
        }

        // Slide 5: Code Example
        function CodeExampleSlide() {
            return (
                <div className="slide-content">
                    <h1>Implementation: OpenAI API Calls</h1>

                    <table className="code-table">
                        <tbody>
                            <tr><td className="code-label">Python: Streaming Completion</td></tr>
                            <tr><td><code>{`from openai import OpenAI

client = OpenAI(api_key="your-api-key")

# Streaming completion
stream = client.chat.completions.create(
    model="gpt-4",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Explain transformers."}
    ],
    temperature=0.7,
    stream=True
)

# Process stream
for chunk in stream:
    content = chunk.choices[0].delta.content
    if content:
        print(content, end="", flush=True)`}</code></td></tr>
                        </tbody>
                    </table>

                    <table className="code-table">
                        <tbody>
                            <tr><td className="code-label">Python: Token Counting</td></tr>
                            <tr><td><code>{`import tiktoken

# Get encoder for model
encoder = tiktoken.encoding_for_model("gpt-4")

text = "Hello, how are you today?"
tokens = encoder.encode(text)

print(f"Text: {text}")
print(f"Tokens: {tokens}")
print(f"Token count: {len(tokens)}")
print(f"Decoded: {[encoder.decode([t]) for t in tokens]}")`}</code></td></tr>
                        </tbody>
                    </table>

                    <div className="highlight-box">
                        <p><strong>Best Practice:</strong> Always use streaming for better UX in production. Users perceive the response as faster when they see tokens appearing.</p>
                    </div>
                </div>
            );
        }

        // Slide 6: Summary
        function SummarySlide() {
            return (
                <div className="slide-content" style={{display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '80vh', textAlign: 'center'}}>
                    <h1 style={{borderBottom: 'none'}}>Demo Complete!</h1>
                    <h3 style={{marginTop: '30px'}}>Key Takeaways</h3>
                    <div style={{textAlign: 'left', maxWidth: '600px', margin: '20px auto'}}>
                        <ul style={{fontSize: '1.1em', lineHeight: '1.8'}}>
                            <li>Tokenization directly impacts cost and context limits</li>
                            <li>English averages ~4 characters per token</li>
                            <li>Temperature controls randomness: 0=deterministic, 1+=creative</li>
                            <li>Time to first token is key UX metric</li>
                            <li>Streaming improves perceived performance</li>
                            <li>Different models have different speed/quality tradeoffs</li>
                        </ul>
                    </div>
                    <p style={{marginTop: '30px', opacity: 0.7}}>Continue to Module 2: AI Agents</p>
                </div>
            );
        }

        // Main App
        function App() {
            const [currentSlide, setCurrentSlide] = useState(0);
            const [apiKey, setApiKey] = useState('');
            const [isConnected, setIsConnected] = useState(false);

            const slides = [
                (props) => <TitleSlide {...props} />,
                (props) => <TokenizationSlide {...props} />,
                (props) => <LiveCompletionSlide {...props} />,
                (props) => <TemperatureComparisonSlide {...props} />,
                () => <CodeExampleSlide />,
                () => <SummarySlide />
            ];
            const totalSlides = slides.length;

            const nextSlide = () => {
                if (currentSlide < totalSlides - 1) {
                    setCurrentSlide(currentSlide + 1);
                }
            };

            const prevSlide = () => {
                if (currentSlide > 0) {
                    setCurrentSlide(currentSlide - 1);
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (e.key === 'ArrowRight' || e.key === ' ') {
                        e.preventDefault();
                        nextSlide();
                    } else if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        prevSlide();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [currentSlide]);

            const CurrentSlideComponent = slides[currentSlide];

            return (
                <div className="slide active">
                    <CurrentSlideComponent
                        apiKey={apiKey}
                        setApiKey={setApiKey}
                        isConnected={isConnected}
                        setIsConnected={setIsConnected}
                    />
                    <div className="navigation">
                        <button className="nav-btn" onClick={prevSlide} disabled={currentSlide === 0}>
                            ← Previous
                        </button>
                        <span className="slide-counter">Slide {currentSlide + 1} of {totalSlides}</span>
                        <button className="nav-btn" onClick={nextSlide} disabled={currentSlide === totalSlides - 1}>
                            Next →
                        </button>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
